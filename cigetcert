#!/usr/bin/env python2.6

# Acronyms used:
#  SP - Service Provider (cilogon)
#  IdP - Identity Provider
#  SAML - Security Assertion Markup Language
#  ECP - Enhanced Client or Proxy SAML Profile

#
# cigetcert gets an X.509 certificate from an SP using the ECP profile.
# Optionally it can also get a grid proxy certificate and/or transfer
#   the proxy to MyProxy.

prog = "cigetcert"
version = "0.1"

import sys
import os
import re
sys.path.append('lxml.egg')
from lxml import etree
import urllib2
import urlparse
import cookielib
import kerberos
import getpass
import base64
import StringIO

from optparse import OptionParser

config = {
    "spurl" : "https://test.cilogon.org/secure",
    "idplisturl" : "https://test.cilogon.org/include/ecpidps.txt"
}

def usage(parser, msg):
    print >> sys.stderr, prog + ": " + msg + '\n'
    parser.print_help(sys.stderr)
    sys.exit(2)

def fatal(msg, code=1):
    print >> sys.stderr, prog + ": " + msg + '\n'
    sys.exit(code)

# this is from http://stackoverflow.com/questions/27227221/error-when-using-xml-api-findall-in-with-python-2-6
def resolve_xpath(xpath, namespace):
    result = xpath
    for short_name, url in namespace.items():
        result = re.sub(r'\b' + short_name + ':', '{' + url + '}', result)
    return result

# this is from http://python-notes.curiousefficiency.org/en/latest/python_kerberos.html
def www_auth(handle):
    auth_fields = {}
    for field in handle.info().getheader("www-authenticate", "").split(","):
	kind, __, details = field.strip().partition(" ")
	auth_fields[kind.lower()] = details.strip()
    return auth_fields

# function from http://stackoverflow.com/questions/4407539/python-how-to-make-an-option-to-be-required-in-optparse
def checkRequiredOptions(options, parser):
    missing_options = []
    for option in parser.option_list:
        if re.search('\(required\)$', option.help) and eval('options.' + option.dest) == None:
            missing_options.extend(option._long_opts)
    if len(missing_options) > 0:
	usage(parser, "Missing required parameters: " + str(missing_options))

def main():
    usagestr = "usage: %prog [options]"
    parser = OptionParser(usage=usagestr, version=version)

    parser.add_option("-v", "--verbose", 
                      action="store_true", dest="verbose", default=False,
                      help="write progress to stdout")
    parser.add_option("-d", "--debug", 
                      action="store_true", dest="debug", default=False,
                      help="write detailed debug output to stdout (implies -v)")
    parser.add_option("-i", "--institution", 
                      action="store", dest="institution", metavar="Name",
                      help="Institution name (required)")
    parser.add_option("", "--idplisturl", 
                      action="store", dest="idplisturl", metavar="URL",
		      default=config['idplisturl'],
                      help="Identity Provider list URL")
    parser.add_option("", "--spurl", 
                      action="store", dest="spurl", metavar="URL",
		      default=config['spurl'],
                      help="Service Provider URL")
    parser.add_option("-k", "--kerberos", 
                      action="store_true", dest="kerberos", default=False,
                      help="prefer kerberos authentication if available")
    parser.add_option("-n", "--noprompt", 
                      action="store_true", dest="noprompt", default=False,
                      help="do not prompt for password (implies --kerberos)")
    parser.add_option("-p", "--promptstr", 
                      action="store", dest="promptstr", metavar="str",
		      default="Password for %username",
                      help="password prompt string")
    parser.add_option("-u", "--username", 
                      action="store", dest="username", metavar="str",
		      default=os.getenv("LOGNAME"),
                      help="username for authentication")

    # add default value (if any) to the help messages that are strings
    for option in parser.option_list:
	if (option.default != ("NO", "DEFAULT")) and (option.action == "store"):
	    option.help += " [default: %default]"

    (options, args) = parser.parse_args()
    if len(args) != 0:
	usage(parser, "no non-option arguments expected")

    checkRequiredOptions(options, parser)

    # set implied options
    if options.debug:
	options.verbose = True
    if options.noprompt:
	options.kerberos = True

    # Set up https handler/opener with cookies
    cookiejar = cookielib.LWPCookieJar()
    cookiehandler = urllib2.HTTPCookieProcessor(cookiejar)
    httpshandler = urllib2.HTTPSHandler()
    if options.debug:
	httpshandler.set_http_debuglevel(1)
    opener = urllib2.build_opener(cookiehandler, httpshandler)

    ### Look up the IdP URL
    if options.verbose:
	print "Fetching list of IdPs from " + options.idplisturl
    idplistrequest = urllib2.Request(url=options.idplisturl)
    try:
	idplisthandle = opener.open(idplistrequest)
    except Exception, e:
	fatal("fetch of idplist from %s failed: %s" % (options.idplisturl, e))
    idplist = idplisthandle.read()
    idplisthandle.close()

    idpurl = None
    idpkrburl = None
    for line in idplist.splitlines():
	idx = line.index(' ')
	name = line[idx+1:]
	if re.match(options.institution + '($| \()', name) != None:
	    url = line[0:idx]
	    if line.endswith(' (Kerberos)'):
		idpkrburl = url
	    else:
		idpurl = url
    if idpkrburl == None:
	# if there's no server explicitly marked for kerberos, it's
	#   possible the regular server supports it
	idpkrburl = idpurl

    if idpkrburl == None:
	fatal('No institution called "' + options.institution + '"\n' +
			'  in ' + options.idplisturl)

    if options.debug:
	print '##### IdP URL: ' + str(idpurl)
	if options.kerberos:
	    print '##### Kerberos IdP URL: ' + str(idpkrburl)

    ### Begin the real SAML communication, starting with the SP ###
    headers = {
	'Accept' : 'text/html; application/vnd.paos+xml',
	'PAOS'   : 'ver="urn:liberty:paos:2003-08";"urn:oasis:names:tc:SAML:2.0:profiles:SSO:ecp"'
    }
    if options.verbose:
	print "Requesting authorization from SP " + options.spurl
    sprequest = urllib2.Request(url=options.spurl,headers=headers)
    try:
	sphandle = opener.open(sprequest)
    except Exception, e:
	fatal("first request to SP %s failed: %s" % (options.spurl,e))
    
    spetree = etree.XML(sphandle.read())
    sphandle.close()

    if options.debug:
	print "##### Begin SP response"
	print etree.tostring(spetree, pretty_print=True)
	print "##### End SP response"

    # these are used for multiple XML parses below
    namespaces = {
        'ecp' : 'urn:oasis:names:tc:SAML:2.0:profiles:SSO:ecp',
        'S'   : 'http://schemas.xmlsoap.org/soap/envelope/',
        'paos': 'urn:liberty:paos:2003-08'
    }

    # pull out the RelayState
    try:
	relaystate = spetree.xpath("//ecp:RelayState", namespaces=namespaces)[0]
    except Exception, e:
	fatal("Unable to parse RelayState element from SP response: %s" % e)

    if options.debug:
	print "###### Begin RelayState element"
	print etree.tostring(relaystate, pretty_print=True)
	print "###### End RelayState element"

    # pull out the responseConsumerURL
    try:
	responseConsumerURL = spetree.xpath("/S:Envelope/S:Header/paos:Request/@responseConsumerURL", namespaces=namespaces)[0]
    except Exception, e:
	fatal("Unable to parse responseConsumerURL from SP response: %s" % e)

    if options.debug:
	print "###### Begin responseConsumerUrl attribute"
	print responseConsumerURL
	print "###### End responseConsumerUrl attribute"

    # remove the SOAP header to pass the AuthnRequest on to the IdP
    idprequestbody = spetree
    header = idprequestbody[0]
    idprequestbody.remove(header)
    # can't pretty print here or the IdP doesn't like it
    idpbody=etree.tostring(idprequestbody)

    if options.debug:
	print "###### Begin IdP request body"
        print etree.tostring(idprequestbody, pretty_print=True)
	print "###### End IdP request body"

    # make a handler that does not raise an error on 401
    class NotAuthHandler(urllib2.HTTPSHandler):
	def http_error_401(self, request, response, code, msg, hdrs):
	    return response
    notauthhandler = NotAuthHandler()
    if options.debug:
	notauthhandler.set_http_debuglevel(1)
    notauthopener = urllib2.build_opener(notauthhandler)

    wwwauthenticate = ""
    unauthidpurl = ""
    if options.kerberos:
	# try Kerberos first
	unauthidpurl = idpkrburl
    elif options.noprompt:
	# this should be disallowed above since noprompt implies kerberos
	fatal("programming error - neither kerberos nor prompt selected")
    else:
	unauthidpurl = idpurl

    if options.verbose:
	print "Making unauthorized request to IdP " + unauthidpurl
    idprequest = urllib2.Request(url=unauthidpurl)
    try:
	idphandle = notauthopener.open(idprequest)
    except Exception, e:
	fatal("Failure on first (unauthorized) request to IdP %s: %s" % (unauthidpurl, e))

    if options.debug:
	print "###### Begin IdP response to unauthorized request"
	print idphandle.info()
	print "###### End IdP response to unauthorized request"

    if idphandle.getcode() != 401:
	fatal("Did not get expected response code 401 from IdP %s, instead got code %d" % (idpkrburl, idphandle.getcode()))
    wwwauthenticate = www_auth(idphandle)
    idphandle.close()

    idphandle = None
    if options.kerberos:
	if 'negotiate' in wwwauthenticate:
	    service = "HTTP@" + urlparse.urlsplit(idpkrburl).hostname
	    if options.debug:
		print "###### Initializing kerberos context for " + service
	    __, krb_context = kerberos.authGSSClientInit(service)
	    kerberos.authGSSClientStep(krb_context, "")
	    negotiate_details = kerberos.authGSSClientResponse(krb_context)
	    headers = {
		'Content-Type': 'text/xml',
		'Authorization': 'Negotiate ' + negotiate_details
	    }

	    # Redo it with kerberos, sending the AuthnRequest in a POST
	    if options.verbose:
		print "Making kerberized request to IdP " + idpkrburl

	    idprequest = urllib2.Request(idpkrburl, headers=headers, data=idpbody)
	    try:
		idphandle = opener.open(idprequest)
	    except Exception, e:
		idphandle = None
		fatal("Failure on response from IdP %s: %s" % (idpkrburl, e))

    if not options.noprompt and (idphandle == None):
	if idpurl == unauthidpurl:
	    if 'basic' not in wwwauthenticate:
		fatal("IdP does not support password authentication")
	# else assume that with two servers that the primary server
	#  supports basic authentication

	# ask for password
	password = getpass.getpass(options.promptstr.replace("%username",options.username) + ': ')
	base64string = base64.encodestring('%s:%s' % (options.username, password)).replace('\n', '')
	headers = {
	    'Content-Type': 'text/xml',
	    'Authorization': 'Basic ' + base64string
	}

	# POST the AuthnRequest to the IDP
	if options.verbose:
	    print "Making authorized request to IdP " + idpurl
	idprequest = urllib2.Request(idpurl, headers=headers, data=idpbody)
	try:
	    idphandle = opener.open(idprequest)
	except Exception, e:
	    fatal("Failure on response from IdP %s: %s" % (idpurl, e))

    idpetree = etree.XML(idphandle.read())
    idphandle.close()

    if options.debug:
	print "###### Begin IdP response"
	print etree.tostring(idpetree, pretty_print=True)
	print "###### End IdP response"

if __name__ == '__main__':
    main()
