#!/usr/bin/env python
#
# cigetcert gets an X.509 certificate from an SP using the ECP profile.
# Optionally it can also get a grid proxy certificate and/or transfer
#   the proxy to MyProxy.
#
# Acronyms used:
#  SP - Service Provider (cilogon)
#  IdP - Identity Provider
#  SAML - Security Assertion Markup Language
#  ECP - Enhanced Client or Proxy SAML Profile
#
# Author: Dave Dykstra dwd@fnal.gov


prog = "cigetcert"
version = "0.1"

import sys
import os
import re
from lxml import etree
import urllib
import urllib2
import urlparse
import cookielib
import kerberos
import getpass
import base64
import StringIO
import string
import random
import warnings
from OpenSSL import crypto

import shlex
from optparse import OptionParser

config = {
    "spurl" : "https://ecp.cilogon.org/secure/getcert",
    "idplisturl" : "https://cilogon.org/include/ecpidps.txt"
}

# make this global
options = None

def usage(parser, msg):
    print >> sys.stderr, prog + ": " + msg + '\n'
    parser.print_help(sys.stderr)
    sys.exit(2)

def fatal(msg, code=1):
    global options
    if (options == None) or not options.quiet:
	print >> sys.stderr, prog + ": " + msg + '\n'
    sys.exit(code)

# this is from http://stackoverflow.com/questions/27227221/error-when-using-xml-api-findall-in-with-python-2-6
def resolve_xpath(xpath, namespace):
    result = xpath
    for short_name, url in namespace.items():
        result = re.sub(r'\b' + short_name + ':', '{' + url + '}', result)
    return result

# this is from http://python-notes.curiousefficiency.org/en/latest/python_kerberos.html
def www_auth(handle):
    auth_fields = {}
    for field in handle.info().getheader("www-authenticate", "").split(","):
	field = field.strip()
	space = field.find(" ")
	if space == -1:
	    space = len(field)
	kind = field[0:space]
	details = field[space+1:]
	auth_fields[kind.lower()] = details.strip()
    return auth_fields

# function from http://stackoverflow.com/questions/4407539/python-how-to-make-an-option-to-be-required-in-optparse
def checkRequiredOptions(options, parser):
    missing_options = []
    for option in parser.option_list:
        if re.search('\(required\)$', option.help) and eval('options.' + option.dest) == None:
            missing_options.extend(option._long_opts)
    if len(missing_options) > 0:
	usage(parser, "Missing required parameters: " + str(missing_options))

def main():
    global options
    hours = 168 # make option later
    usagestr = "usage: %prog [-h] [otheroptions]"
    parser = OptionParser(usage=usagestr, version=version)

    parser.add_option("-v", "--verbose", 
                      action="store_true", dest="verbose", default=False,
                      help="write progress to stdout")
    parser.add_option("-d", "--debug", 
                      action="store_true", dest="debug", default=False,
                      help="write detailed debug output to stdout (implies -v)")
    parser.add_option("-q", "--quiet", 
                      action="store_true", dest="quiet", default=False,
                      help="do not print error messages")
    parser.add_option("-s", "--optserver", 
                      action="store", dest="optserver", metavar="HostOrURL",
                      help="server or URL with default %s options" % prog)
    parser.add_option("-i", "--institution", 
                      action="store", dest="institution", metavar="Name",
                      help="Institution name (required)")
    parser.add_option("", "--idplisturl", 
                      action="store", dest="idplisturl", metavar="URL",
		      default=config['idplisturl'],
                      help="Identity Provider list URL")
    parser.add_option("", "--spurl", 
                      action="store", dest="spurl", metavar="URL",
		      default=config['spurl'],
                      help="Service Provider URL")
    parser.add_option("-k", "--kerberos", 
                      action="store_true", dest="kerberos", default=False,
                      help="prefer kerberos authentication if available")
    parser.add_option("-n", "--noprompt", 
                      action="store_true", dest="noprompt", default=False,
                      help="do not prompt for password (implies --kerberos)")
    parser.add_option("-p", "--promptstr", 
                      action="store", dest="promptstr", metavar="str",
		      default="Password for %username@%realm",
                      help="prompt string")
    parser.add_option("-u", "--username", 
                      action="store", dest="username", metavar="str",
		      default="$LOGNAME",
                      help="username for authentication")
    parser.add_option("-o", "--out", 
                      action="store", dest="out", metavar="path",
		      default="/tmp/x509up_u%uid",
                      help="File path to save certificate and key chain")

    # add default value (if any) to the help messages that are strings
    for option in parser.option_list:
	if (option.default != ("NO", "DEFAULT")) and (option.action == "store"):
	    option.help += " [default: %default]"

    (options, args) = parser.parse_args()
    if len(args) != 0:
	usage(parser, "no non-option arguments expected")

    # Set up https handler/opener with cookies
    cookiejar = cookielib.CookieJar()
    cookiehandler = urllib2.HTTPCookieProcessor(cookiejar)
    httpshandler = urllib2.HTTPSHandler()
    if options.debug:
	httpshandler.set_http_debuglevel(1)
    # need to avoid redirects
    class NoRedirectHandler(urllib2.HTTPRedirectHandler):
	def http_error_302(self, request, response, code, msg, hdrs):
	    if options.debug:
		print "###### Ignoring redirect"
	    return response
    noredirecthandler = NoRedirectHandler()
    opener = urllib2.build_opener(cookiehandler, noredirecthandler, httpshandler)
    if options.optserver != None:
	# read additional options from optserver
	optserver = options.optserver
	if optserver.find('://') == -1:
	    optserver = 'https://' + optserver + '/' + prog + 'opts.txt'
	if options.verbose or options.debug:
	    print "Fetching options from " + optserver
	optrequest = urllib2.Request(url=optserver)
	try:
	    opthandle = opener.open(optrequest)
	except Exception, e:
	    fatal("fetch of options from %s failed: %s" % (optserver, e))
	opts = opthandle.read()
	if options.debug:
	    print "##### Begin additional options"
	    print opts
	    print "##### End additional options"
	try:
	    extraargs = shlex.split(opts, True)
	except Exception, e:
	    fatal("parsing options from %s failed: %s" % (optserver, e))
	(options, args) = parser.parse_args(extraargs + sys.argv[1:])
	if len(args) != 0:
	    usage(parser, "non-option arguments found at %s" % optserver)

    checkRequiredOptions(options, parser)

    # set implied options
    if options.debug:
	options.verbose = True
    if options.noprompt:
	options.kerberos = True

    ### Look up the IdP URL
    if options.verbose:
	print "Fetching list of IdPs from " + options.idplisturl
    idplistrequest = urllib2.Request(url=options.idplisturl)
    try:
	idplisthandle = opener.open(idplistrequest)
    except Exception, e:
	fatal("fetch of idplist from %s failed: %s" % (options.idplisturl, e))
    idplist = idplisthandle.read()

    idpurl = None
    idpkrburl = None
    for line in idplist.splitlines():
	idx = line.index(' ')
	name = line[idx+1:]
	if re.match(options.institution + '($| \()', name) != None:
	    url = line[0:idx]
	    if line.endswith(' (Kerberos)'):
		idpkrburl = url
	    else:
		idpurl = url
    if idpkrburl == None:
	# if there's no server explicitly marked for kerberos, it's
	#   possible the regular server supports it
	idpkrburl = idpurl

    if idpkrburl == None:
	fatal('No institution called "' + options.institution + '"\n' +
			'  in ' + options.idplisturl)

    if options.debug:
	print '##### IdP URL: ' + str(idpurl)
	if options.kerberos:
	    print '##### Kerberos IdP URL: ' + str(idpkrburl)

    ### Begin the real SAML communication, starting with the SP ###
    headers = {
	'Accept' : 'text/html; application/vnd.paos+xml',
	'PAOS'   : 'ver="urn:liberty:paos:2003-08";"urn:oasis:names:tc:SAML:2.0:profiles:SSO:ecp"'
    }
    if not options.spurl.endswith('/'):
	options.spurl += '/'
    if options.verbose:
	print "Requesting authorization from SP " + options.spurl
    sprequest = urllib2.Request(url=options.spurl,headers=headers)
    try:
	sphandle = opener.open(sprequest)
    except Exception, e:
	fatal("first request to SP %s failed: %s" % (options.spurl,e))
    
    spetree = etree.XML(sphandle.read())

    if options.debug:
	print "##### Begin SP response"
	print etree.tostring(spetree, pretty_print=True)
	print "##### End SP response"

    # these are used for multiple XML parses below
    namespaces = {
        'ecp' : 'urn:oasis:names:tc:SAML:2.0:profiles:SSO:ecp',
        'S'   : 'http://schemas.xmlsoap.org/soap/envelope/',
        'paos': 'urn:liberty:paos:2003-08'
    }

    # pull out the RelayState
    try:
	relayState = spetree.xpath("//ecp:RelayState", namespaces=namespaces)[0]
    except Exception, e:
	fatal("Unable to parse RelayState element from SP response: %s" % e)

    if options.debug:
	print "###### Begin RelayState element"
	print etree.tostring(relayState, pretty_print=True)
	print "###### End RelayState element"

    # pull out the responseConsumerURL
    try:
	responseConsumerURL = spetree.xpath("/S:Envelope/S:Header/paos:Request/@responseConsumerURL", namespaces=namespaces)[0]
    except Exception, e:
	fatal("Unable to parse responseConsumerURL from SP response: %s" % e)

    if options.debug:
	print "###### Begin responseConsumerUrl attribute"
	print responseConsumerURL
	print "###### End responseConsumerUrl attribute"

    # remove the SOAP header to pass the AuthnRequest on to the IdP
    idprequestbody = spetree
    header = idprequestbody[0]
    idprequestbody.remove(header)
    # can't pretty print here or the IdP doesn't like it
    idpbody=etree.tostring(idprequestbody)

    if options.debug:
	print "###### Begin IdP request body"
        print etree.tostring(idprequestbody, pretty_print=True)
	print "###### End IdP request body"

    # make a handler that does not raise an error on 401
    class NotAuthHandler(urllib2.HTTPSHandler):
	def http_error_401(self, request, response, code, msg, hdrs):
	    return response
    notauthhandler = NotAuthHandler()
    if options.debug:
	notauthhandler.set_http_debuglevel(1)
    notauthopener = urllib2.build_opener(notauthhandler)

    wwwauthenticate = ""
    unauthidpurl = ""
    if options.kerberos:
	# try Kerberos first
	unauthidpurl = idpkrburl
    elif options.noprompt:
	# this should be disallowed above since noprompt implies kerberos
	fatal("programming error - neither kerberos nor prompt selected")
    else:
	unauthidpurl = idpurl

    def dounauthrequest(url):
	if options.verbose:
	    print "Making unauthorized request to IdP " + url
	idprequest = urllib2.Request(url=url)
	try:
	    notauthidphandle = notauthopener.open(idprequest)
	except Exception, e:
	    fatal("Failure on (deliberately) unauthorized request to IdP %s: %s" % (url, e))

	if options.debug:
	    print "###### Begin IdP response to unauthorized request"
	    print notauthidphandle.info()
	    print "###### End IdP response to unauthorized request"

	if notauthidphandle.code != 401:
	    fatal("Did not get expected response code 401 from IdP %s, instead got code %d" % (url, notauthidphandle.code))
	return www_auth(notauthidphandle)

    wwwauthenticate = dounauthrequest(unauthidpurl)

    idphandle = None
    if options.kerberos:
	if 'negotiate' in wwwauthenticate:
	    netloc = urlparse.urlsplit(idpkrburl)[1]
	    hostname = re.sub(":.*", "", netloc)
	    service = "HTTP@" + hostname
	    if options.debug:
		print "###### Initializing kerberos context for " + service
	    __, krb_context = kerberos.authGSSClientInit(service)
	    try:
		kerberos.authGSSClientStep(krb_context, "")
	    except Exception, e:
		if options.noprompt:
		    fatal("Kerberos initialization failed: %s" % e)
		if options.verbose:
		    print "Kerberos initialization failed: %s" % e
		    print "Trying password"
		else:
		    print "Unable to obtain kerberos credentials, trying password"
	    else:
		negotiate_details = kerberos.authGSSClientResponse(krb_context)
		headers = {
		    'Content-Type': 'text/xml',
		    'Authorization': 'Negotiate ' + negotiate_details
		}

		# Redo it with kerberos, sending the AuthnRequest in a POST
		if options.verbose:
		    print "Making kerberized request to IdP " + idpkrburl

		idprequest = urllib2.Request(idpkrburl, headers=headers, data=idpbody)
		try:
		    idphandle = opener.open(idprequest)
		except Exception, e:
		    idphandle = None
		    fatal("Failure on response from IdP %s: %s" % (idpkrburl, e))

    if not options.noprompt and (idphandle == None):
	if idpurl != unauthidpurl:
	    wwwauthenticate = dounauthrequest(idpurl)

	if 'basic' not in wwwauthenticate:
	    fatal("IdP does not support password authentication")

	# ask for password
	username = options.username.replace("$LOGNAME", os.getenv("LOGNAME"));
	promptstr = options.promptstr.replace("%username",username)
	if (promptstr.find('%realm') != -1):
	    basic = wwwauthenticate['basic']
	    if basic.find('realm=') == -1:
		fatal("IdP did not supply realm for password prompt")
	    realm = re.sub('.*realm="', '', basic)
	    realm = re.sub('".*', '', realm)
	    promptstr = promptstr.replace("%realm", realm)
	password = getpass.getpass(promptstr + ': ')
	base64string = base64.encodestring('%s:%s' % (username, password)).replace('\n', '')
	headers = {
	    'Content-Type': 'text/xml',
	    'Authorization': 'Basic ' + base64string
	}

	# POST the AuthnRequest to the IDP
	if options.verbose:
	    print "Making authorized request to IdP " + idpurl
	idprequest = urllib2.Request(idpurl, headers=headers, data=idpbody)
	try:
	    idphandle = opener.open(idprequest)
	except Exception, e:
	    fatal("Failure on response from IdP %s: %s" % (idpurl, e))

    idpetree = etree.XML(idphandle.read())

    if options.debug:
	print "###### Begin IdP response"
	print etree.tostring(idpetree, pretty_print=True)
	print "###### End IdP response"

    # pull out the AsssertionConsumerServiceURL
    try:
	assertionConsumerServiceURL = idpetree.xpath("/S:Envelope/S:Header/ecp:Response/@AssertionConsumerServiceURL", namespaces=namespaces)[0]
    except Exception, e:
	fatal("Unable to parse AssertionConsumerServiceURL from IdP response: %s" % e)

    if options.debug:
	print "###### Begin AssertionConsumerServiceURL attribute"
	print assertionConsumerServiceURL
	print "###### End AssertionConsumerServiceURL attribute"

    if assertionConsumerServiceURL != responseConsumerURL:
	# IdP's response doesn't match SP's expectation
	if options.verbose:
	    print "Telling SP that IdP had a response error"
        soapfault = """
            <S:Envelope xmlns:S="http://schemas.xmlsoap.org/soap/envelope/">
               <S:Body>
                 <S:Fault>
                    <faultcode>S:Server</faultcode>
                    <faultstring>responseConsumerURL from SP and assertionConsumerServiceURL from IdP do not match</faultstring>
                 </S:Fault>
               </S:Body>
            </S:Envelope>
            """
        headers = { 'Content-Type' : 'application/vnd.paos+xml' }
	request = urllib2.Request(responseConsumerURL, headers=headers, data=soapfault)
        # POST the fault to the SP but ignore any failure
        try:
            handle = opener.open(request)
        except Exception, e:
            pass

	fatal("assertionConsumerServiceURL %s from IdP does not match responseConsumerURL %s from SP" % (assertionConsumerServiceURL, responseConsumerURL))

    # replace the header of the idp response with the relay state sent by the
    #  Assertion Consumer (which is on the SP)
    acrequestbody = idpetree
    acrequestbody[0][0] = relayState
    acbody=etree.tostring(acrequestbody)

    if options.debug:
	print "###### Begin SP Assertion Consumer body"
        print etree.tostring(acrequestbody, pretty_print=True)
	print "###### End SP Assertion Consumer body"


    if options.verbose:
	print "Sending response to Assertion Consumer " + assertionConsumerServiceURL
    headers = { 'Content-Type' : 'application/vnd.paos+xml' }
    acrequest = urllib2.Request(assertionConsumerServiceURL, headers=headers, data=acbody)
    try:
	achandle = opener.open(acrequest)
    except Exception, e:
	fatal("Failure on response from assertion consumer %s: %s" % (assertionConsumerServiceURL, e))

    # Ignore the response body. We only want the cookie which the opener
    #   has already stored in the cookiejar.

    shibcookie = cookiejar.make_cookies(achandle, acrequest)[0]
    if options.debug:
	print "###### Begin shibboleth cookie"
        print [shibcookie]
	print "###### End shibboleth cookie"

    # Add a 10-character random Cross Site Request Forgery prevention cookie.
    # It also has to be a form value in order to pass the CILogon CSRF check.
    csrfstr = string.join(
	(random.choice(string.ascii_lowercase+string.digits) for _ in range(10)),
	'')
    headers = {
	'Content-Type' : 'application/x-www-form-urlencoded',
	'Cookie' : 'CSRF=' + csrfstr + '; ' +
	    shibcookie.name + '=' + shibcookie.value
    }

    # generate a Certificate Signing Request
    if options.verbose:
	print "Generating Certificate Signing Request"
    key = crypto.PKey()
    key.generate_key(crypto.TYPE_RSA,2048)
    privkey = crypto.dump_privatekey(crypto.FILETYPE_PEM, key)
    csreq = crypto.X509Req()
    csreq.set_pubkey(key)
    if 'set_version' in dir(csreq):
	# this function isn't in python2.4, but cilogon has seen
	#  problems without it
	csreq.set_version(0)
    csreq.sign(key, "sha256")
    csr = crypto.dump_certificate_request(crypto.FILETYPE_PEM, csreq)
    if options.debug:
	print "###### Begin csr"
        print csr
	print "###### End csr"

    certformvars = [
	('submit' , 'certreq'),
	('CSRF' , csrfstr),
	('certlifetime' , hours),
	('certreq' , csr)
    ]
    certformdata = urllib.urlencode(certformvars)

    if options.verbose:
	print "Requesting certificate from SP " + options.spurl
    spcertrequest = urllib2.Request(url=options.spurl,data=certformdata, 
    		headers=headers)
    try:
	spcerthandle = opener.open(spcertrequest)
    except Exception, e:
	fatal("cert request to SP %s failed: %s" % (options.spurl,e))

    cert = spcerthandle.read()
    if options.debug:
	print "###### Begin cert"
        print cert
	print "###### End cert"
    if not cert.startswith('-----BEGIN CERTIFICATE-----'):
	fatal("response from SP does not contain a certificate")

    out = options.out.replace("%uid", str(os.getuid()))

    if options.verbose:
	print "Storing certificate chain in " + out
    handle = os.fdopen(os.open(out, os.O_WRONLY | os.O_CREAT | os.O_TRUNC, 0600), 'w')
    handle.write(cert)
    handle.write('\n')
    handle.write(privkey)

if __name__ == '__main__':
    main()
